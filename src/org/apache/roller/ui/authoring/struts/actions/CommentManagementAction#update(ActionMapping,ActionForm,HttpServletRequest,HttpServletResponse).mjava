    public ActionForward update(
            ActionMapping       mapping,
            ActionForm          actionForm,
            HttpServletRequest  request,
            HttpServletResponse response) 
            throws IOException, ServletException, RollerException {
        
        CommentManagementForm queryForm = (CommentManagementForm)actionForm;
        RollerRequest rreq = RollerRequest.getRollerRequest(request);
        if (rreq.getWeblogEntry() != null) {
            queryForm.setEntryid(rreq.getWeblogEntry().getId());
            queryForm.setWeblog(rreq.getWeblogEntry().getWebsite().getHandle());
        }        
        else if (rreq.getWebsite() != null) {
            queryForm.setWeblog(rreq.getWebsite().getHandle());
        } 
        else {
            // user needs Global Admin rights to access site-wide comments
            RollerSession rses = RollerSession.getRollerSession(request);
            if (!rses.isGlobalAdminUser()) {
                return mapping.findForward("access-denied");
            }
        }
        RollerSession rses = RollerSession.getRollerSession(request);
        try {
            if (rses.isGlobalAdminUser() 
                || (rreq.getWebsite()!=null && rses.isUserAuthorizedToAuthor(rreq.getWebsite())) ) { 
                WeblogManager mgr= RollerFactory.getRoller().getWeblogManager();
                
                // delete all comments with delete box checked
                CommentData deleteComment = null;
                String[] deleteIds = queryForm.getDeleteComments();
                List deletedList = Arrays.asList(deleteIds);
                if (deleteIds != null && deleteIds.length > 0) {
                    for(int j=0; j < deleteIds.length; j++) {
                        deleteComment = mgr.getComment(deleteIds[j]);
                        
                        mgr.removeComment(deleteComment);
                    }
                }
                
                // Collect comments approved for first time, so we can send
                // out comment approved notifications later
                List approvedComments = new ArrayList();
                
                // loop through IDs of all comments displayed on page
                String[] ids = Utilities.stringToStringArray(queryForm.getIds(),",");
                List flushList = new ArrayList();
                for (int i=0; i<ids.length; i++) {                    
                    if (deletedList.contains(ids[i])) continue;                    
                    CommentData comment = mgr.getComment(ids[i]);
                    
                    // apply spam checkbox 
                    List spamIds = Arrays.asList(queryForm.getSpamComments());
                    if (spamIds.contains(ids[i])) {
                        comment.setStatus(CommentData.SPAM);
                    }
                    
                    // Only participate in comment review workflow if we're
                    // working within one specfic weblog. Global admins should
                    // be able to mark-as-spam and delete comments without 
                    // interfering with moderation by bloggers.
                    if (rreq.getWebsite() != null) {
                        
                        // set comments as either APPROVED or DISAPPROVED
                        List approvedIds = 
                            Arrays.asList(queryForm.getApprovedComments());
                        if (approvedIds.contains(ids[i])) {
                            // if a comment was previously PENDING then this is
                            // it's first approval, so track it for notification
                            if(CommentData.PENDING.equals(comment.getStatus())) {
                                approvedComments.add(comment);
                            }
                            
                            // update status to APPROVED
                            comment.setStatus(CommentData.APPROVED);
                            
                        } else if (!spamIds.contains(ids[i])) {
                            // remaining non-spam comments get DISAPPROVED status
                            comment.setStatus(CommentData.DISAPPROVED);
                        }
                    }
                    
                    // save changes to this comment
                    mgr.saveComment(comment);
                    flushList.add(comment);
                }
                
                RollerFactory.getRoller().flush();
                for (Iterator comments=flushList.iterator(); comments.hasNext();) {
                    CacheManager.invalidate((CommentData)comments.next());
                }
                
                sendCommentNotifications(request, approvedComments);
                
                ActionMessages msgs = new ActionMessages();
                msgs.add(ActionMessages.GLOBAL_MESSAGE, 
                    new ActionMessage("commentManagement.updateSuccess"));
                saveMessages(request, msgs);
            }
        } catch (Exception e) {
            ActionMessages errors = new ActionMessages();
            errors.add(ActionErrors.GLOBAL_MESSAGE,
                new ActionMessage("commentManagement.updateError",e.toString()));
            saveErrors(request, errors);
            logger.error("ERROR updating comments", e);       
        }
        CommentManagementPageModel model = new CommentManagementPageModel(
           "commentManagement.title", request, response, mapping, queryForm);
        request.setAttribute("model", model); 
        if (request.getAttribute("commentManagementForm") == null) {
            request.setAttribute("commentManagementForm", actionForm);
        }
        
        if (rreq.getWebsite() != null) {
            return mapping.findForward("commentManagement.page");
        }
        return mapping.findForward("commentManagementGlobal.page");
    }

