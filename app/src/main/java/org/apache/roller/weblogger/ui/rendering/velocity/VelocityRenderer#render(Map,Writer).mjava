    public void render(Map model, Writer out) throws RenderingException {
        
        try {

            if(parseException != null) {
                
                Context ctx = new VelocityContext(model);
                ctx.put("exception", parseException);
                ctx.put("exceptionSource", renderTemplate.getId());
                ctx.put("utils", new UtilitiesModel());
                
                // render output to Writer
                velocityTemplate.merge(ctx, out);
                
                // and we're done
                return;
            }
            
            long startTime = System.currentTimeMillis();
            
            // convert model to Velocity Context
            Context ctx = new VelocityContext(model);
            
            if (velocityDecorator != null) {
                
                /**
                 * We only allow decorating once, so the process isn't
                 * fully recursive.  This is just to keep it simple.
                 */
                
                // render base template to a temporary StringWriter
                StringWriter sw = new StringWriter();
                velocityTemplate.merge(ctx, sw);
                
                // put rendered template into context
                ctx.put("decorator_body", sw.toString());
                
                log.debug("Applying decorator "+velocityDecorator.getName());
                
                // now render decorator to our output writer
                velocityDecorator.merge(ctx, out);
                
            } else {
                
                // no decorator, so just merge template to our output writer
                velocityTemplate.merge(ctx, out);
            }
            
            long endTime = System.currentTimeMillis();
            long renderTime = (endTime - startTime)/1000;
            
            log.debug("Rendered ["+renderTemplate.getId()+"] in "+renderTime+" secs");
            
        } catch (Exception ex) {
            // wrap and rethrow so caller can deal with it
            throw new RenderingException("Error during rendering", ex);
        }
    }

